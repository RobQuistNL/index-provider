# Indexer Reference Provider Design
The goal of this reference implementation is to flesh out all the protocol details
for data providers to be able to interact with indexer nodes. 

## Overview
- Data providers keep a local index of all the data they are providing.
- Data providers are responsible for the advertisement of updates related to the data they are providing.
        - Data providers must be able to uniquely identify the batches of data they are providing, and/or the
        announcements they broadcast to the network in order to be able to serve indexer-node data ingestion requests.
- Indexer nodes listen to advertisement from data providers. When they come across a previously unseeend
advertisement for a data provider, they trigger a new ingestion session to sync with the provider. 

## Data Structures
Data providers and indexer nodes can use any internal representation they want for indexed data. They only
data structures enforced by the protocol are in the interaction between the two.

### Advertisements
Advertisements are used by data providers to share updates about the data they are providing. Ideally,
these advertisements are published in a shared pub-sub channel between providers and indexer nodes. However,
some indexer nodes may choose to provide a dedicated endpoint to allow certain authenticated providers to push announcements and updates directly to them.
        - `Pull` Advertisements: Indexer-nodes pull advertisement from a shared pub-sub channel.
        - `Push` Advertisements: Authenticated providers can push advertisements to indexer-nodes.

```go
type Advertisement struct {
        ID              AdvertisementID
        Previous        AdvertisementID
        Provider        peer.ID
        Signature       []byte
        GraphSupport    bool
        
}
```
- `ID` is the unique identifier used by the data provider to identify this update.
- `Previous` links the current advertisement for the provider with the previous one. This allows
providers to track the announcements they are broadcasting, and 
indexer nodes to realize when they have missed a previous advertisement.
- `Provider` determines the source of the advertisement.
- `Signature` is a signature over `ID` and `Previous` to authenticate that the advertisement has been generated by `Provider`.
- `GraphSupport` is used by providers to signal indexer nodes that they support IPLD-aware ingestion sessions (see [protocol](#protocol)).

`AdvertisementID` can be chosen by data providers in the way that suit them best according to their internal
data indexing strategy. The only requirement for
`AdvertisementID` is that it should allow providers to uniquely identify the batch of data, or data update
they are referring to in the advertisement. Indexer nodes use these IDs in their ingestion requests to fetch indexing
data from the provider.

For instance, a Filecoin miner may choose to use as `AdvertisementID` a combination of a `dealID` with a prefix to identify if
the advertisement points to a new deal or the expiration of a deal. Thus, when a miner receives an ingestion
request for `AdvertisementID` from an indexer node, it can easily build the ingestion response (either with the
batch of new CIDs provided in the deal, or with the list of CIDs the indexer should stop providing due to a deal expiration). Other data providers may choose to generate their `AdvertisementID`s in alternative ways.

For indexer nodes, `AdvertisementID` is an opaque `String` and has no additional significance apart from the unique ID
for a data provider advertisement.

```go
type AdvertisementID String
```
<!-- We may not need to include `Previous` in Advertisements, as they can be signalled in Ingestion responses. When an advertisement is seen, a request is sent to providers, and providers can signal the previous one. Then the indexer chooses if it is already in sync or not. However, chaining advertisements comes pretty handy for data providers, as it gives them a way to identify the sequence of updates and serve ingestion requests -->

### Ingestion Request
When an indexer node finds an unseen `Advertisement` and realizes that it is not in sync with a data provider, it sends
an ingestion request to the data provider to index/remove data.
```go
type IngestionRequest struct {
        ID              AdvertisementID
        Start           uint64
        Count           uint64
}
```
- `ID`: `AdvertisementID` for which data is being requested.
- `Start`: Starting entry from which data wants to be requested.
- `Count`: Maximum number of entries that want to be received in the response.
....
### Ingestion Response
Data providers use `IngestionResponse`s to answer to ingestion requests.

```go
type IngestionResponse struct {
        Size            uint64
        Error           uint32  // optional
        Start           uint64  // optional
        Advertisement   Advertisement // optional
        Entries         []Entry
}
```
- `Size`: Total entries included for `AdvertisementID`.
- `Error`: Error code (if any).
- `Start`: Index of the first entry of the response.
- `Advertisement`: Advertisement to which this response (and thus indexing data) belongs to.
- `Entries`: The actual entries with the new/removed CIDs.


```go
type Entry struct {
        IsRm            bool
        Cids            []cid.Cid   // NOTE: We can probably use String instead of cid.Cid
        Metadata        []byte

}
```
- `IsRm`: Flags if the cids included in the entry should be added or removed from hte indexer node.
- `Cids`: List of CIDs included in the entry.
- `Metadata`: Metadata to index for CIDs in the entry. If `IsRm = true` it doesn't make sense to add `Metadata` in the Entry.

## Interfaces
### Data Provider
Interface implemented by data providers for the interaction with indexer nodes.

```go
type IngestionServer interface {
        // Broadcast advertisement to the network
        func Broadcast (ctx context.Context, ad Advertisement) error
        
        // Push an update for a single entry.
        // This can be used to perform updates for a small number of CIDs
        // When a full advertisement is not worth it (web3.storage case).
        // Indexer may only accept pushes from authenticated providers.
        func Push (ctx context.Context, indexer peer.ID, entry Entry) 
}
```

Data providers need to include protocol handlers able to process and serve indexer node 
ingestion requests (see [protocol](#protocol)).

### Indexer Node
Interface implemented by indexer nodes for the interaction with data providers.

```go
type IngestionClient interface{
        // Ingest requests the ingestion of a specific range of updates
        func Ingest (ctx context.Context, p peer.ID, firstID AdvertisementID, lastID AdvertisementID) error

        // Sync with a data provider up to latest ID
        func Sync (ctx context.Context, p peer.ID, latest AdvertisementID) error
}

```

Data providers need to include protocol handlers able to process and serve indexer node 
push Advertisements and immediate ingestions (see [protocol](#protocol)).

## Protocol
The interaction protocol between data providers and indexer nodes can be divided in two subprotocols: the advertisement protocol, and the ingestion protocol.

## Advertisement Protocol
It orchestrates the announcement of udpates from data providers to indexer nodes. Every time a data provider receives
an update for the data they provide (e.g. new deal in a Filecoin miner), they may choose to broadcast an `Advertisement`
to the network so indexer nodes can start indexing this data. Three kinds of updates will initially be supported:
        - `Pull` Advertisements: Data providers broadcast the `Advertisement` for the new data using a shared
        pub-sub channel. When indexer nodes see these updates, they trigger an ingestion session to sync with the
        data provider.
        - `Push` Advertisements: Some indexer nodes may support advertisement pushes by data providers. Indexers 
        will trigger a new ingestion session to gather the data for that update. 
        - `Immediate` Ingestion: Some data providers may want to share updates for a small number of CIDs which doesn't
        require the generation of a dedicated `Advertisement` and triggering an ingestion session. For this case, indexer
        nodes will provide an endpoint for providers to push small updates directly to them. Indexer nodes may
        restrict immediate ingestion updates to authenticated data providers __(we3.storage case)__.

## Ingestion Protocol
When indexer nodes realize that they are not in sync with a data provider they are indexing data for, they trigger
new ingestion sessions with them to gather the new updates. This is orchestrated by the ingestion protocol.

Indexer nodes track locally the latest `AdvertisementID` seen for each data provider. When an `Advertisement` for an unseen `AdvertisementID` is seen for a data provider, a new ingestion session is triggered with the data provider.

Data providers are responsible for broadcasting `Advertisement`s and generating their `AdvertisementID`s in the way that
suits them best. This means that they may choose to use IPLD data structures under the hood to link their advertisements
with their indexed data, so that `AdvertisementID` is a link to the indexed data for that `Advertisement`. If this is
the case, the provider may set the `GraphSupport` flag in its `Advertisement` to signal indexer nodes that they
can use IPLD-aware data transfer protocol, such as Graphsync, for the ingestion session.

Thus, according to how the data providers choose to represent their indexed data locally, two flavors of the ingestion protocols can be instantiated by the indexer node.

### IPLD-unaware
This is the default request-response ingestion protocol used by indexer nodes. When an indexer node triggers
a new `Sync` with provider `p`, for `latest AdvertisementID`:
        - Indexer node checks the last `AdvertisementID` seen for `p`, `current`.
        - It sends a request to ingest the data related with `latest` advertisement, `Sync(ctx, p, latest).
```go
req = IngestionRequest{
        ID: latest
        Start: 0, 
}
```
        - Provider will answer with the list of entries for `latest` pointing to the previous `AdvertisementID` in the `Advertisement` field
```go
resp = IngestionResponse {
        Size: 2
        Error: 0
        Start: 0
        Advertisement: Advertisement{
                ID: latest,
                Previous: "latest-1",
                Provider: p,
                Signature: []byte{}, 
                GraphSupport: false, 
        }
        Entries: {
                []Entry{
                        Cids: {Cid1, Cid2, ...},
                        Metadata: []byte{}
                }
}
```
- If `Size` > `len(Entries), the indexer-node sends a new request to keep fetching data for `latest` with `Start: 1`
until all entries for the Advertisement have been received. It then inspects `Advertisement` to see if `Previous` is equal
to the latest `AdvertisementID` seen for that provider, if this is not the case, it sends a new request with `latest-1`
and repeats the process over and over again until the `AdvertisementID` seen in `Previous` for the latest response
equals the latest one seen by indexer node for that data provider.
- Note that pagination is performed at an `Entry` level, i.e. there is no intra-Entry pagination (at least not initially). The data provider should be responsible for dividing single Entries with a large number of CIDs into
smaller entries when computing the `Size` of the data indexed in `AdvertisementID`. If we identify this as too strong
of a requirement, we can also introduce intra-Entry pagination to support seamless exchange of entries with a large
amount of CIDs.
- Once the full sync is performed, the indexer node updates the latest AdvertisementID seen for `p` to latest.
- Indexer nodes run ingestion sessions for different providers in parallel, so an indexer node can sync with several provideres in parallel.
- Indexer nodes can include a `prov_parallel_ingestion` config to determine if it wants to support parallel ingestions for
the same provider. If `prov_parallel_ingestion = 0` new `Advertisement`s arriving for an indexer node while `syncing` are queued, and are processed after the sync for the provider is done. If `prov_parallel_ingestion > 0`, the indexer node
tracks `Sync` sessions, and new Advertisements trigger new ingestion sessions with the provider for a non-overlapping
range between the current syncs and the new one. Thus, if there is a ingestion session with `latest = ID1` and
a new advertisement arrives with `AdvertisementID: ID2` and `prov_parallel_ingestion > 0` then a new ingestion
session is started for the range `(ID1, ID2] with `Ingest(ctx, p, ID1, ID2)`.

### IPLD-aware
If a data provider is indexing data in a way that `AdvertisementID` is linked with the indexed data using IPLD, it may enable
the `GraphSupport` flag in its Advertisements to signal indexer nodes that they can use IPLD-aware data transfer
protocols.

When an indexer node sees an unseen advertisement `latest`, it will trigger an ingestion session to sync with the
data provider. If `GraphSupport` is enabled the indexer node can use Graphsync or `go-data-transfer` to fetch `latest` DAG, which links to the data that needs to be ingested, using a [`ExploreRecursiveEdge`](https://ipld.io/specs/selectors/) selector. `latest` will include a link to the data structure for the previous `AdvertisementID` to latest, so Graphsync is able to fetch all the chain of updates from the provider seamlessly up to the latest one seen by the indexer node.

Once the sync process is finished, the indexer node updates the latest AdvertisementID seen for provider to `latest`.

```go
// Example of internal data structure of an index of data provider.
type AdvertisementID Index_Link

type Index struct {
        Previous: Index_Link{},
        Entries: []Entry{
                IsRm:           bool
                Cids:           []cid.Cid,        // NOTE: This can also be string.
                Metadata:       []byte,
        },
} 
```

__NOTE: We need to build the selector or the IPLD storer in the indexer node so that it checks the latest Advertisement
seen and it terminates Graphsync's DAG traversal conveniently.__

## Open Questions / Discussion / Future Work
- ...
- ...
